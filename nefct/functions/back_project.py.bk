from nefct import nef_class, Any
from nefct.utils import tqdm
from nefct.data.image import Image2D, Image3D, Image
from nefct.data.projection import ProjectionSequence2D, ProjectionSequence3D
from nefct.geometry.scanner_config import ScannerConfig, ScannerConfig2D, ScannerConfig3D
import numpy as np
import tensorflow as tf
from nefct.data.deform_para import DeformParameter


__all__ = ('BackProject', 'BackProject2D', 'BackProject3D')
new_op_mod = tf.load_op_library('/home/bill52547/Github/tensorflow/bazel-bin/tensorflow/core/user_ops/new_op_mod.so')
bproj_op = new_op_mod.back_project

mc_bproj_op = new_op_mod.mc_back_project

@nef_class
class BackProject:
    config: ScannerConfig

    def __call__(self, *args, **kwargs) -> Image:
        pass


@nef_class
class BackProject3D(BackProject):
    config: ScannerConfig3D
    shape: np.ndarray
    unit_size: np.ndarray

    def __call__(self, proj: ProjectionSequence3D) -> Image3D:
        mode = self.config.mode

        config = {
            'angles': proj.angles,
            'offsets': proj.offsets / self.unit_size,
            'mode': 0 if proj.mode == 'flat' else 1,
            'nx': self.shape[0],
            'ny': self.shape[1],
            'nz': self.shape[2],
            'SO': self.config.SAD / self.unit_size,
            'SD': self.config.SID / self.unit_size,
            'na': self.config.detector_a.number,
            'da': self.config.detector_a.unit_size,
            'ai': self.config.detector_a.offset,
            'nb': self.config.detector_b.number,
            'db': self.config.detector_b.unit_size / self.unit_size,
            'bi': self.config.detector_b.offset / self.unit_size
        }

        if mode == 'flat':
            config['da'] /= self.unit_size
            config['ai'] /= self.unit_size
        else:
            pass
        bproj_data = bproj_op(proj.data.transpose(),
                                       **config).numpy().transpose()
        return Image3D(bproj_data * self.unit_size, np.ndarray([0,0,0]),
                       self.shape * self.unit_size)


@nef_class
class McBackProject3D(BackProject):
    config: ScannerConfig3D
    deform_config: DeformParameter
    shape: np.ndarray
    unit_size: np.ndarray

    def __call__(self, proj: ProjectionSequence3D) -> Image3D:
        mode = self.config.mode

        config = {
            'angles': proj.angles,
            'offsets': proj.offsets / self.unit_size,
            'mode': 0 if proj.mode == 'flat' else 1,
            'nx': self.shape[0],
            'ny': self.shape[1],
            'nz': self.shape[2],
            'SO': self.config.SAD / self.unit_size,
            'SD': self.config.SID / self.unit_size,
            'na': self.config.detector_a.number,
            'da': self.config.detector_a.unit_size,
            'ai': self.config.detector_a.offset,
            'nb': self.config.detector_b.number,
            'db': self.config.detector_b.unit_size / self.unit_size,
            'bi': self.config.detector_b.offset / self.unit_size
        }

        if mode == 'flat':
            config['da'] /= self.unit_size
            config['ai'] /= self.unit_size
        else:
            pass
        bproj_data = bproj_op(proj.data.transpose(),
                                       **config).numpy().transpose()
        return Image3D(bproj_data * self.unit_size, np.ndarray([0,0,0]),
                       self.shape * self.unit_size)
