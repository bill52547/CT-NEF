from nefct import nef_class, Any
from nefct.data.image import Image2D, Image3D, Image, Image2DT, Image3DT
from nefct.data.projection import ProjectionSequence2D, \
    ProjectionSequence3D, ProjectionSequence
from nefct.geometry.scanner_config import ScannerConfig, ScannerConfig2D, ScannerConfig3D
from nefct.data.deform_para import DeformParameter
import numpy as np
import tensorflow as tf

__all__ = ('Project', 'Project2D', 'Project3D')

new_op_mod = tf.load_op_library(
    '/home/bill52547/Github/tensorflow/bazel-bin/tensorflow/core/user_ops/new_op_mod.so'
)
proj_op = new_op_mod.project
mc_proj_op = new_op_mod.mc_project


@nef_class
class Project:
    def __call__(self, image: Image) -> ProjectionSequence:
        pass


@nef_class
class Project3D(Project):
    config: ScannerConfig3D

    def __call__(self,
                 image: Image,
                 angles: np.ndarray,
                 offsets: np.ndarray = None) -> ProjectionSequence3D:
        if offsets is None:
            offsets = angles * 0

        config = {
            'angles': angles,
            'offsets': offsets / image.unit_size[0],
            'mode': 0 if self.config.mode == 'flat' else 1,
            'SO': self.config.SAD / image.unit_size[0],
            'SD': self.config.SID / image.unit_size[0],
            'nx': image.shape[0],
            'ny': image.shape[1],
            'nz': image.shape[2],
            'na': self.config.detector_a.number,
            'da': self.config.detector_a.unit_size,
            'ai': self.config.detector_a.offset,
            'nb': self.config.detector_b.number,
            'db': self.config.detector_b.unit_size / image.unit_size[0],
            'bi': self.config.detector_b.offset / image.unit_size[0]
        }

        if self.config.mode == 'flat':
            config['da'] /= image.unit_size[0]
            config['ai'] /= image.unit_size[0]
        else:
            pass
        proj_data = proj_op(image.data.transpose(),
                            **config).numpy().transpose()
        return ProjectionSequence3D(proj_data * image.unit_size[0],
                                    self.config, angles, offsets)


@nef_class
class McProject3D(Project):
    config: ScannerConfig3D
    deform_config: DeformParameter

    def __call__(self,
                 image: Image,
                 angles: np.ndarray,
                 offsets: np.ndarray = None,
                 v: np.ndarray = None,
                 f: np.ndarray = None,
                 deform_config: DeformParameter = None) -> ProjectionSequence3D:
        if offsets is None:
            offsets = angles * 0
        config = {
            'angles': self.config.angles,
            'offsets': offsets / image.unit_size[0],
            'ax': deform_config.ax.transpose(),
            'ay': deform_config.ay.transpose(),
            'az': deform_config.az.transpose(),
            'bx': deform_config.bx.transpose(),
            'by': deform_config.by.transpose(),
            'bz': deform_config.bz.transpose(),
            'cx': deform_config.cx.transpose(),
            'cy': deform_config.cy.transpose(),
            'cz': deform_config.cz.transpose(),
            'v_data': v,
            'f_data': f,
            'mode': 0 if self.mode == 'flat' else 1,
            'SO': self.config.SAD / image.unit_size[0],
            'SD': self.config.SID / image.unit_size[0],
            'nx': image.shape[0],
            'ny': image.shape[1],
            'nz': image.shape[2],
            'na': self.config.detector_a.number,
            'da': self.config.detector_a.unit_size,
            'ai': self.config.detector_a.offset,
            'nb': self.config.detector_b.number,
            'db': self.config.detector_b.unit_size / image.unit_size[0],
            'bi': self.config.detector_b.offset / image.unit_size[0]
        }

        if self.config.mode == 'flat':
            config['da'] /= image.unit_size[0]
            config['ai'] /= image.unit_size[0]
        else:
            pass
        proj_data = mc_proj_op(image.data.transpose(),
                            **config).numpy().transpose()
        return ProjectionSequence3D(proj_data * image.unit_size[0],
                                    self.config, angles, offsets)
